#  第 5 章  创建高性能的索引

索引（在 MySQL 中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。

##  5.1  索引基础

MySQL 存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

###  5.1.1  索引的类型

MySQL 中，索引是在存储引擎层而不是服务器层实现的。因此没有统一的索引标准：不同存储引擎的索引工作方式不一样。

####  B-Tree 索引

- 当人们谈论索引时，若非特别指明类型，多半说的是 B-Tree 索引（使用 B-Tree 数据结构来存储数据）；
- 实际上很多存储引擎使用的是 B+Tree，即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的遍历范围（InnoDB 使用 B+Tree）；
- B-Tree 通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同；
- 叶子节点比较特别，它们的指针指向的是被索引的数据，而非其他节点；
- B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。

可以使用 B-Tree 索引的查询类型。B-Tree 索引适用于全键值、键值范围或键前缀查找（只适用于根据最左前缀的查找）。索引对如下类型的查询有效：

- 全值匹配：和索引中的所有列进行匹配；
- 匹配最左前缀：只使用索引的第一列；
- 匹配列前缀：只匹配某一列的值的开头部分；
- 匹配范围值
- 精确匹配某一列并范围匹配另一列
- 只访问索引的查询

> 因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的 `ORDER BY` 操作。

**B-Tree 索引的限制**

- 若非按照索引的最左列开始查找，则无法使用索引；
- 不能跳过索引中的列；
- 若查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

> 索引列的顺序很重要！
>
> 优化性能时，可能需要使用相同的列，但顺序不同的索引来满足不同类型的查询需求。

####  哈希索引

哈希索引（hash index）基于哈希表实现，只有精确匹配所有列的查询才有效。

PS: MySQL 中，只有 Memory 引擎显式支持哈希索引。



> InnoDB 引擎有一个特殊的功能叫做“自适应哈希索引（adaptive hash index）”。
>
> 当 InnoDB 注意到某些索引值被使用得非常频繁时，会在内存中基于 B-Tree 索引之上再创建一个哈希索引，这样让 B-Tree 索引也具有哈希索引的一些优点。
>
> 这是完全自动的内部行为，不可控制或配置，但可以关闭。

####  空间数据索引（R-Tree）

了解：MyISAM 表支持空间索引。这类索引无需前缀查询，空间索引会从所有纬度来索引数据。

####  全文索引

一种特殊类型的索引，查找的是文本中的关键词，而不是直接比较索引中的值。

全文索引更类似于搜索引擎做的事情，而非简单的 `WHERE` 条件匹配。

##  5.2  索引的优点

1. 大大减少了服务器需要扫描的数据量；
2. 帮助服务器避免排序和临时表；
3. 将随机 I/O 变为顺序 I/O。

##  5.3  高性能的索引策略

###  5.3.1  独立的列

如果查询中的列不是独立的，则 MySQL 不会使用索引。示例代码：

```mysql
SELECT actor_id FROM user_info WHERE actor_id + 1 = 5;
```

###  5.3.2  前缀索引和索引选择性

#### 前缀索引

- 前缀索引：有时需要索引很长的字符列，会让索引变得很大而且慢。通常可以索引开始的部分字符。对于 BLOB、TEXT 或很长的 VARCHAR 类型的列，必须使用前缀索引。
- 创建前缀索引，示例代码：

```mysql
ALTER TABLE sakila.city_demo ADD KEY (city(7));
```

####  索引选择性

- 索引选择性是指：不重复的索引值（也成为基数，cardinality）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。
- 选择性越高则查询效率越高（因为选择性高的索引可以让 MySQL 在查询时过滤掉更多的行）。唯一索引的选择性是 1. 这是最好的索引选择性，性能也是最好的。
- 计算完整列的选择性，示例代码：

```mysql
SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
```

- 计算不同前缀长度的选择性，示例代码：

```mysql
SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3,
	   COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4
FROM sakila.city_demo;
```

###  5.3.4  选择合适的索引列顺序

- 在一个多列 B-Tree 索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。因此，多列索引的列顺序至关重要。
- 经验法则（参考）：将选择性最高的列放到索引最前列。

###  5.3.5  聚簇索引

TODO

###  5.3.6  覆盖索引

- 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称之为“覆盖索引”。覆盖索引能极大地提高性能。
- 并非所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，因此 MySQL 只能使用 B-Tree 索引作为覆盖索引。

###  5.3.7  使用索引扫描来做排序

















