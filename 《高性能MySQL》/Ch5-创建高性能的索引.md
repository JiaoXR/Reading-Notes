#  第 5 章  创建高性能的索引

索引（在 MySQL 中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。

##  5.1  索引基础

MySQL 存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

###  5.1.1  索引的类型

MySQL 中，索引是在存储引擎层而不是服务器层实现的。因此没有统一的索引标准：不同存储引擎的索引工作方式不一样。

####  B-Tree 索引

- 当人们谈论索引时，若非特别指明类型，多半说的是 B-Tree 索引（使用 B-Tree 数据结构来存储数据）；
- 实际上很多存储引擎使用的是 B+Tree，即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的遍历范围（InnoDB 使用 B+Tree）；
- B-Tree 通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同；
- 叶子节点比较特别，它们的指针指向的是被索引的数据，而非其他节点；
- B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。

可以使用 B-Tree 索引的查询类型。B-Tree 索引适用于全键值、键值范围或键前缀查找（只适用于根据最左前缀的查找）。索引对如下类型的查询有效：

- 全值匹配：和索引中的所有列进行匹配；
- 匹配最左前缀：只使用索引的第一列；
- 匹配列前缀：只匹配某一列的值的开头部分；
- 匹配范围值
- 精确匹配某一列并范围匹配另一列
- 只访问索引的查询

> 因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的 `ORDER BY` 操作。

**B-Tree 索引的限制**

- 若非按照索引的最左列开始查找，则无法使用索引；
- 不能跳过索引中的列；
- 若查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

> 索引列的顺序很重要！
>
> 优化性能时，可能需要使用相同的列，但顺序不同的索引来满足不同类型的查询需求。

####  哈希索引

哈希索引（hash index）基于哈希表实现，只有精确匹配所有列的查询才有效。

PS: MySQL 中，只有 Memory 引擎显式支持哈希索引。



> InnoDB 引擎有一个特殊的功能叫做“自适应哈希索引（adaptive hash index）”。
>
> 当 InnoDB 注意到某些索引值被使用得非常频繁时，会在内存中基于 B-Tree 索引之上再创建一个哈希索引，这样让 B-Tree 索引也具有哈希索引的一些优点。
>
> 这是完全自动的内部行为，不可控制或配置，但可以关闭。

####  空间数据索引（R-Tree）

了解：MyISAM 表支持空间索引。这类索引无需前缀查询，空间索引会从所有纬度来索引数据。

####  全文索引

一种特殊类型的索引，查找的是文本中的关键词，而不是直接比较索引中的值。

全文索引更类似于搜索引擎做的事情，而非简单的 `WHERE` 条件匹配。

##  5.2  索引的优点

1. 大大减少了服务器需要扫描的数据量；
2. 帮助服务器避免排序和临时表；
3. 将随机 I/O 变为顺序 I/O。

##  5.3  高性能的索引策略

###  5.3.1  独立的列

如果查询中的列不是独立的，则 MySQL 不会使用索引。示例代码：

```mysql
SELECT actor_id FROM user_info WHERE actor_id + 1 = 5;
```

###  5.3.2  前缀索引和索引选择性

#### 前缀索引

- 前缀索引：有时需要索引很长的字符列，会让索引变得很大而且慢。通常可以索引开始的部分字符。对于 BLOB、TEXT 或很长的 VARCHAR 类型的列，必须使用前缀索引。
- 创建前缀索引，示例代码：

```mysql
ALTER TABLE sakila.city_demo ADD KEY (city(7));
```

####  索引选择性

- 索引选择性是指：不重复的索引值（也成为基数，cardinality）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。
- 选择性越高则查询效率越高（因为选择性高的索引可以让 MySQL 在查询时过滤掉更多的行）。唯一索引的选择性是 1. 这是最好的索引选择性，性能也是最好的。
- 计算完整列的选择性，示例代码：

```mysql
SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
```

- 计算不同前缀长度的选择性，示例代码：

```mysql
SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3,
	   COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4
FROM sakila.city_demo;
```

###  5.3.4  选择合适的索引列顺序

- 在一个多列 B-Tree 索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。因此，多列索引的列顺序至关重要。
- 经验法则（参考）：将选择性最高的列放到索引最前列。

###  5.3.5  聚簇索引

TODO

###  5.3.6  覆盖索引

- 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称之为“覆盖索引”。覆盖索引能极大地提高性能。
- 并非所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，因此 MySQL 只能使用 B-Tree 索引作为覆盖索引。

###  5.3.7  使用索引扫描来做排序

- MySQL 有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描（若 `EXPLAIN` 出来的 `type` 列值为 'index'，说明 MySQL 使用了索引扫描做排序）。
- 

###  5.3.8  压缩（前缀压缩）索引

MyISAM 使用前缀压缩来减少索引的大小，在某些情况下能极大地提高性能。代价是某些操作可能更慢。

###  5.3.9  冗余和重复索引

####  重复索引

- 重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即删除。

####  冗余索引

- 若创建了索引 (A, B)，再创建索引 (A) 就是冗余索引（因为这只是前者的前缀索引）。因此索引 (A, B) 也可以当做索引 (A) 来使用【只对 B-Tree 索引来说】。但若再创建索引 (B, A) 则不是冗余索引，索引 (B) 也不是。
- 此外，其他不同类型的索引（哈希索引或全文索引）也不会是 B-Tree 索引的冗余索引。
- 大多情况下不需要冗余索引，应该尽量扩展已有的索引，而非创建新的索引【除非扩展已有的索引会导致其变得太大而影响查询性能】。

- 一般来说，增加新索引会导致 INSERT、UPDATE、DELETE 等操作的速度变慢。表中的索引越多，插入速度会越慢。

###  5.3.10  未使用的索引

###  5.3.11  索引和锁

- InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量。
- InnoDB 在二级索引上使用共享（读）锁，但访问主键索引需要排它（写）锁。

##  5.5  维护索引和表

维护表的目的：

- 找到并修复损坏的表；
- 维护准确的索引统计信息；
- 减少碎片。

###  5.5.1  找到并修复损坏的表

- 检查&修复表

```mysql
-- 检查表是否损坏
CHECK TABLE <table_name>

-- 修复损坏的表
REPAIR TABLE <table_name>
```

- 上述命令并非所有引擎都支持，若不支持，可通过一个不做任何操作（no-op）的 ALTER 操作来重建表，例如修改表的存储引擎为当前的引擎：

```mysql
ALTER TABLE test ENGINE=INNODB;
```

###  5.5.3  减少索引和数据的碎片

表的数据存储碎片化有三种：

- 行碎片：数据行被存储为多个地方的多个片段中。
- 行间碎片：逻辑上顺序的页或行，在磁盘上不是顺序存储的。
- 剩余空间碎片：数据页中有大量的空余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。

重新整理数据：

```mysql
OPTIMIZE TABLE <table_name>
```

若引擎不支持该命令，可通过一个不做任何操作（no-op）的 ALTER 操作来重建表（见 5.5.1）。

##  5.6  总结

- 单行访问很慢；使用索引可以创建位置引用以提升效率。
- 按顺序访问范围数据很快；
  - 顺序 I/O 无需多次磁道寻道，所以比随机 I/O 快很多；
  - 若按需要顺序读取数据，则无需额外的排序。
- 索引覆盖查询很快。若索引包含了查询所需的所有列，那么存储引擎就无需再回表查找行。避免了大量的单行访问。

