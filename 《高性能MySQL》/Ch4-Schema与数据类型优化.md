#  第 4 章  Schema 与数据类型优化

##  4.1  选择优化的数据类型

几个原则：

- 更小的通常更好

更小的数据类型通常更快，它们占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。例如，若只需存 0~200，tinyint unsigned 更好。

- 简单就好

简单数据类型的操作通常需要更少的 CPU 周期。例如，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符串比较比整型更复杂。

- 尽量避免 NULL
  - 通常情况下最好指定列为 NOT NULL，除非真的需要存储 NULL。
  - 若查询包含可为 NULL 的列，对 MySQL 来说更难优化，因为可为 NULL 的列使得索引、索引统计和值比较都都更复杂。
  - 可为 NULL 的列会使用更多的存储空间，在 MySQL 需要特殊处理。
  - 通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小，所以（调优时）没有必要首先在现有的 schema 中修改这种情况。但如果计划在列上建索引，应尽量避免设计成可为 NULL 的列。
  - 例外：InnoDB 使用单独的位（bit）存储 NULL 值，所以对于稀疏数据（很多值为 NULL，只有少数行的列有非 NULL 值）有很好的空间效率。但不适用于 MyISAM。

###  4.1.1  整数类型

有两种类型的数字：整数（whole number）和实数（real number）。

- 整数类型：`TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT` ；
- 分别使用 8，16，24，32，64 位存储空间（即 1，2，3，4，8 个字节）；
- 存储范围为 -2^(N-1) ~ 2^(N-1)-1，N 为位数。
- MySQL 可以为整型指定宽度，例如 `INT(11)`, 但对多数应用无意义：它不会限制值得合法范围（只是规定了 MySQL 的一些交互工具显示字符的个数）。对于存储和计算来说，`INT(1)` 和 `INT(20)` 是相同的。

###  4.1.2  实数类型

- 实数是带有小数部分的数字。MySQL 既支持精确类型，也支持不精确类型。

- DECIMAL 类型用于存储精确的小数，也可以存储比 BIGINT 还大的整数。
- MySQL 5.0 和更高版本中，DECIMAL 类型允许最多 65 个数字。
- 浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。FLOAT 使用 4 个字节，DOUBLE 使用 8 个字节，相比 FLOAT 有更高的精度和更大的范围。MySQL 使用 DOUBLE 作为内部浮点计算的类型。
- 因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用 DECIMAL。数据量较大时，可以使用 BIGINT 代替 DECIMAL（扩大相应的倍数）。

###  4.1.3  字符串类型

- MySQL 4.1 开始，每个字符串列可以定义自己的字符集和排序规则（或校对规则，collation）。这些东西会很大程度上影响性能。

####  VARCHAR 和 CHAR 类型

> 注意：存储引擎存储 CHAR 或者 VARCHAR 值的方式在内存中和在磁盘上可能不一样。

- VARCHAR
  - 存储可变长字符串，比定长类型更节省空间（仅使用必要的空间，越短的字符串使用越少的空间）。特殊情况，如果 MySQL 使用 ROW_FORMAT=FIXED 创建，则每一行都使用定长存储。
  - 需要使用 1 或 2 个额外字节记录字符串的长度。
  - 适用情景：
    - 字符串列的最大长度比平均长度大很多；
    - 列的更新很少，碎片不成问题；
    - 使用了像 UTF-8 这样复杂的字符集，每个字符都使用不同的字节数进行存储。
- CHAR
  - 定长类型字符串，MySQL 会根据定义的字符串长度分配足够的空间。
  - <u>存储 CHAR 值时，MySQL 会删除所有的末尾空格</u>。
  - 适用情景：
    - 很短的字符串（定长不易产生碎片），例如 CHAR(1) 存储 Y 和 N，比 VARCHAR 更节省空间；
    - 所有值都接近同一个长度的字符串（例如 MD5 值）；

####  BLOB 和 TEXT 类型

BLOB 和 TEXT 都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

- TEXT 家族：TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT；TEXT 是 SMALLTEXT 的同义词。
- BLOB 家族：TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB；BLOB 是 SMALLBLOB 的同义词。

注意：

1. 二者仅有的区别：BLOB 类型存储的是二进制数据，没有排序规则或字符集；而 TEXT 类型有字符集和排序规则。
2. MySQL 对 BLOB 和 TEXT 列进行排序与其他类型不同：它只针对每个列最前 `max_sort_length` 字节而非整个字符串做排序。
3. MySQL 不能将 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。

####  使用枚举（ENUM）代替字符串类型

- MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 `.frm` 文件中保存“数字-字符串”映射关系的“查找表”。

###  4.1.4  日期和时间类型

####  DATETIME

- 能保存大范围的值（范围：1001 年到 9999 年），精度为秒；
- 使用八个字节存储；格式：`2018-10-20 15:19:24` ，与时区无关。

####  TIMESTAMP

- 保存了从1970年1月1日午夜（GMT）以来的秒数，和 UNIX 时间戳相同；
- 占用 4 个字节存储，依赖于时区；
- 保存范围（1970 年到 2038 年）比 DATETIME 小得多；
- 默认为 `NOT NULL`.

##  4.2  MySQL schema 设计中的缺陷

- 太多的列
- 太多的关联
- 全能的枚举（枚举使用太多）
- 变相的枚举

##  4.3  范式和反范式

- 在范式化的数据库中，每个事实数据会出现并且只出现一次；反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

###  4.3.1  范式的优点和缺点

- 优点
  - 更新操作通常比反范式化快；
  - 数据较好地范式化时，就只有很少或没有重复数据，只需要修改更少的数据；
  - 范式化的表通常更小，可以更好地放在内存里，所以操作会更快；
  - 检索列表数据时，更少需要 DISTINCT 或 GROUP BY。
- 缺点
  - 通常需要关联，可能导致索引失效。

###  4.3.2  反范式的优点和缺点

- 优点
  - 很好地避免关联；
  - 数据比内存大时，可能比关联要快得多；
  - 能使用更有效地索引策略；
- 缺点

###  4.3.3  混用范式化和反范式化

- 实际中经常混用范式化和反范式化。

##  4.4  缓存表和汇总表

- 有时提升性能最好的方法是在同一张表中保存衍生的冗余数据；有时也需要创建一张完全独立的汇总表或缓存表（例如保存 `GROUP BY` 聚合的数据）。

###  4.4.2  计数器表

- 示例代码：

```mysql
UPDATE hit_count SET cnt = cnt + 1 WHERE slot = RAND() * 100;
SELECT SUM(cnt) FROM hit_count;
```

- `ON DUPLICATE KEY UPDATE`



> 更快地读，更慢地写：
>
> 为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但却是设计高性能数据库时常用技巧：虽然写操作更慢了，但更显著地提高了读操作的性能。

##  4.5  加快 ALTER TABLE 操作的速度

- MySQL 的 ALTER TABLE 操作的性能对大表来说是个大问题。
- MySQL 执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查询出所有数据插入新表，然后删除旧表。

####  修改默认值的示例代码

- 很慢的方式

```mysql
ALTER TABLE sakila.film
MODIFY COLUMN rental_duration TINYINT(3) NOT NULL DEFAULT 5;
```

- 很快的方式

```mysql
ALTER TABLE sakila.film
ALTER COLUMN rental_duration SET DEFAULT 5;
```

`ALTER TABLE` 是让人痛苦的操作，因为在大部分情况下，它都会锁表并且重建整张表。

