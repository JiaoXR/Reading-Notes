# 2-2  垃圾收集器与内存分配策略

## 3.2  对象已死吗

在堆（Heap）里存放着 Java 中几乎所有的对象实例，垃圾收集器在对堆进行回收前，首先要确定这些对象中哪些还“活着”，哪些已经死去（即不能再被任何途径使用）。

### 3.2.1  引用计数法（Reference Counting）

给对象中添加一个引用计数器，每当有地方引用它时，计数器值加 1；当引用失效时，计数器减 1；任何时刻计数器为 0 的对象不能再被使用。

- 优点：简单高效，判定效率高；

- 缺点：难以解决对象间的循环引用问题。

###3.2.2  可达性分析（Reachability Analysis）算法 

基本思路：通过一系列称为 "GC Roots" 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连，则证明此对象是不可用的。如图所示：

![](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/GC_Reachability-Analysis.png)

Java 中，可作为 GC Roots 的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（即 Native 方法）引用的对象。

###  3.2.3  再谈引用

- 强引用（Strong Reference）
  - 在程序代码中普遍存在的，类似 `Object obj = new Object();` 这类引用；
  - 只要强引用还存在，垃圾收集器永远不会回收被引用的对象。

- 软引用（Soft Reference）
  - 用来描述一些还有用、但非必需的对象，用 `java.lang.ref.SoftReference` 表示；
  - 对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。因此，这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。

- 弱引用（Weak Reference）
  - 也用来描述非必需对象，强度比软引用更弱一些，用 `java.lang.ref.WeakReference` 表示；
  - 被弱引用关联的对象只能生存到下一次垃圾收集发生之前（即，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象）。
- 虚引用（Phantom Reference）
  - 也称幽灵引用或幻影引用，最弱的一种引用关系；
  - 一个对象是否有虚引用，完全不对其生存时间有影响，无法通过虚引用取得对象实例；
  - 目的：能在被关联的对象被回收时，收到一个系统通知。

###  3.2.4  生存还是死亡

- 两次标记；
- finalize() 方法（不建议使用）；
- 任何一个对象的 finalize() 方法都只会被系统自动调用一次；

### 3.2.5  回收方法区

方法区（HotSpot 虚拟机中的永久代）的垃圾收集主要回收两部分内容：

- 废弃常量（与回收 Java 堆中的对象非常类似）；
- 无用的类；



判定一个类是否“无用的类”需要同时满足下列条件：

- 该类所有的实例都已经被回收（即 Java 堆中不存在该类的任何实例）；
- 加载该类的 ClassLoader 已经被回收；
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

##  3.3  垃圾收集算法

###  3.3.1  标记-清除算法

标记-清除（Mark-Sweep）算法，最基础的收集算法。分为“标记”和“清除”两个阶段：

- 首先标记出所有需要回收的对象；
- 在标记完成后统一回收所有被标记的对象。

示意图：

![](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/GC_Mark-Sweep.jpg)

优点：实现简单。

####  缺点

- 效率较低，标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片（碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作）。

###  3.3.2  复制算法

复制（Copying）算法：将可用内存按容量分为大小相等的两块，每次只使用其中的一块。当这一块用完了，就将还存活的对象复制到另外一块上，然后再把已使用的内存空间一次清理掉。

示意图：

![](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/GC_Copying.jpg)

- 优点：实现简单，运行高效且不易产生内存碎片；
- 缺点：能够使用的内存缩减到原来的一半；

> 一般不需要按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 控件和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。

> HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1。我们无法保证每次每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

###  3.3.3  标记-整理算法

标记-整理（Mark-Compat）算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

示意图：

![](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/GC_Mark-Compat.jpg)

###  3.3.4  分代收集算法

当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法：根据对象存活周期的不同，将内存划分为几块。一般把 Java 堆分为新生代和老年代，可根据各个年代的特点采用最适当的收集算法。

- 新生代

每次垃圾收集时，都有大批对象死去，只有少量存活，采用复制算法（只需复制少量存活对象）。

- 老年代

对象存活率较高，没有额外空间对它进行分配担保，必须使用“标记-清除”或“标记-整理”算法进行回收。

##  3.4  HotSpot 的算法实现

###  3.4.1  枚举根节点

###  3.4.2  安全点

###  3.4.3  安全区域



##  3.5  垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

HotSpot 虚拟机的垃圾收集器如图所示：

![](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/HotSpot_GC.png)

PS: 存在连线表示可以搭配使用。

###  3.5.1  Serial 收集器

Serial 收集器是最基本、发展历史最悠久的收集器。

- 特点

  - 单线程收集，且垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束；

  - "Stop The World"；

  - 优于其他收集器的地方：简单而高效（与其他收集器的单线程比）

    对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

  - 虚拟机 Client 模式下默认新生代收集器；

示意图：

![](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/GC_Serial.png)

###  3.5.2  ParNew 收集器

ParNew 收集器就是 Serial 收集器的多线程版本。

示意图：

![](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/GC_ParNew.png)

JDK 1.5 时期，HotSpot 推出了 CMS 收集器（Concurrent Mark Sweep），是 HotSpot 中第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

#### 名词解释

- 并行（Parallel）

多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。

- 并发（Concurrent）

指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个 CPU 上。

###  3.5.3  Parallel Scavenge 收集器























