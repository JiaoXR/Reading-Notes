#  3-2  虚拟机类加载机制

##  7.1  概述

- 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

- 在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成，这虽然会令类加载时增量一些性能开销，但是会为 Java 应用程序提供高度的灵活性。

##  7.2  类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7 个阶段。其中验证、准备、解析 3 个部分统称为连接（Linking）。



JVM 规范没有强制约束类加载的时机，但严格规定了有且只有 5 种情况必须立即对类进行初始化：

1. 遇到 new、getstatic、putstatic 和 invokestatic指令（场景：使用 new 实例化对象，读取/设置类的静态字段等）；
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时，如果类没有进行过初始化；
3. 初始化时发现父类还没有进行初始化；
4. 虚拟机启动指定的主类（包含 main 方法的类）；
5. 动态语言中 MethodHandle 实例最后解析结果 REF_getStatic 等的方法句柄对应的类没有初始化时；

##  7.3  类加载的过程

###  7.3.1  加载

加载阶段，虚拟机要完成的事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流；
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

###  7.3.2  验证

- 验证是连接阶段的第一步，目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。
- 验证是虚拟机对自身保护的一项重要工作，这个阶段是否严谨，直接决定 JVM 是否能承受恶意代码的攻击。
- 验证阶段大致上会完成 4 个阶段的检验动作
  - 文件格式验证（是否符合 Class 文件格式等）
  - 元数据验证（确保符合 Java 语言规范）
  - 字节码验证（该阶段最复杂，主要是确定语义合法、符合逻辑）
  - 符号引用验证（目的是确保解析动作能正常执行）

###  7.3.3  准备

- 正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
  - 此时分配内存的仅包括类变量（`static` 修饰的变量）；
  - 初始值“通常情况”下是数据类型的零值，赋值动作在初始化阶段执行；但若为 `static final` 则直接赋值。

###  7.3.4  解析

- 解析阶段是虚拟机将常量池内的符号引用（如 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等）替换为直接引用的过程；

###  7.3.5  初始化

- 类加载过程的最后一步，真正开始执行类中定义的 Java 程序代码（或者说是字节码）。可以认为初始化阶段是执行类构造器 &lt;clinit&gt;() 方法的过程；
- &lt;clinit&gt;() 与类的构造函数（或者说实例构造器 &lt;clinit&gt;() 方法）不同，它不需要显式地调用父类的构造器，虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行之前，父类的 &lt;clinit&gt;() 方法已经执行完毕。因此在虚拟机中第一个被执行的 &lt;clinit&gt;() 方法肯定是 `java.lang.Object`。

##  7.4  类加载器

VM 设计团队把类加载阶段中的"通过一个类的全限定类名来获取描述此类的二进制字节流"这个动作放到 JVM 外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为"类加载器"。

###  7.4.1  类与类加载器

- 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 JVM 中的唯一性，每一个类加载器都拥有一个独立的类名称空间。
- 比较两个类是否“相等”（包括 Class 对象的 equals 方法、isAssignableFrom、isInstance 的返回结果），只有在这两个类是由同一个类加载器加载的前提下才有意义；否则，即使两个类源自同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。
- 示例代码

```java
package com.jaxer.example.jvm;

public class ClassLoaderTest {
    public static void main(String[] args) throws Exception {
        ClassLoader myLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";
                    InputStream inputStream = getClass().getResourceAsStream(fileName);
                    if (inputStream == null) {
                        return super.loadClass(name);
                    }
                    byte[] bytes = new byte[inputStream.available()];
                    inputStream.read(bytes);
                    return defineClass(name, bytes, 0, bytes.length);
                } catch (IOException e) {
                    throw new ClassNotFoundException();
                }
            }
        };

        Object obj = myLoader.loadClass("com.jaxer.example.jvm.ClassLoaderTest").newInstance();
        System.out.println(obj.getClass());
        System.out.println(obj instanceof ClassLoaderTest);
    }
}

// 运行结果：
// class com.jaxer.example.jvm.ClassLoaderTest
// false
```

###  7.4.2  双亲委派模型

#### 两种类加载器

从 JVM 角度看，只存在两种不同的类加载器：

1. 启动类加载器（Bootstrap ClassLoader）：使用 C++ 语言实现（HotSpot 虚拟机），是虚拟机的一部分
2. 所有其他的类加载器：由 Java 语言实现，独立于虚拟机外部，且都继承自抽象类 `java.lang.ClassLoader`

#### 三种类加载器

从 Java 开发人员角度，绝大部分程序会用到三种系统提供的类加载器：

- 启动类加载器（Bootstrap ClassLoader）

    - 负责将存放在 <JAVA_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。
    - 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，若需要把加载请求委托给引导类加载器，直接使用 null 代替即可。

    示例代码：

    ```java
    @CallerSensitive
    public ClassLoader getClassLoader() {
        ClassLoader cl = getClassLoader0();
        if (cl == null)
            return null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
        }
        return cl;
    }
    ```

- 扩展类加载器（Extension ClassLoader）
    - 由 `sun.misc.Launcher$ExtClassLoader` 实现。负责加载 <JAVA_HOME>\lib\ext 目录中的，或者被 `java.ext.dirs` 系统变量所指定的路径中的所有类库。开发者可直接使用。
- 应用程序类加载器（Application ClassLoader）
    - 由 `sun.misc.Launcher$AppClassLoader` 实现，是 ClassLoader 中 getSystemClassLoader() 方法的返回值，一般称为"系统类加载器"。
    - 负责加载用户类路径（ClassPath）上所指定的类库，开发者可直接使用。若未自定义过类加载器，一般情况下这个就是程序中默认的类加载器。

#### 双亲委派模型

应用程序一般由这三种类加载器互相配合进行加载，必要时可加入自定义类加载器，关系图如下：

![parents_delegation_model](https://github.com/JiaoXR/Reading-Notes/blob/master/pics/JVM/parents_delegation_model.png)

该层次关系称为类加载器的**双亲委派模型（Parents Delegation Model）**。这些类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是使用组合（Composition）来复用父加载器的代码。

- 工作过程
  - 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成；只有父类加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
- 好处
    - Java 类随着它的类加载器具备了一种带有优先级的层次关系
    - 对保证 Java 程序的稳定运作很重要
- 代码实现：`java.lang.ClassLoader` 的 `loadClass()` 方法

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }
            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);
                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

###  7.4.3  破坏双亲委派模型

- OSGi 已经成为了业界“事实上”的 Java 模块化标准，其实现模块化热部署的关键是它自定义的类加载器机制的实现：每个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。

当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：

1. 将以 `java.*` 开头的类委派给父类加载器加载；
2. 否则，将委派列表名单内的类委派给父类加载器加载；
3. 否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载；
4. 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载；
5. 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载；
6. 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。
7. 否则，类查找失败。

> Java 程序员中基本有一个共识：OSGi 中对类加载器的使用时很值得学习的，弄懂了 OSGi 的实现，就可以算是掌握了类加载器的精髓。

