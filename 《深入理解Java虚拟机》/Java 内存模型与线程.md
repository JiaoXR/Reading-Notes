#  Java 内存模型与线程



衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second, TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而 TPS 的值与程序的并发能力又有非常密切的关系。



处理器、高速缓存（Cache）和主内存之间的交互关系如图 12-1 所示：

![12-1](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/cache_coherence.png)



缓存一致性（Cache Conherence）

内存模型，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。



###  Java 内存模型

Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各种硬件和操作系统的内存访问诧异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

> 根据 Java 虚拟机规范的规定，volatile 变量依然有工作内存的拷贝，但是由于它特殊的操作顺序规定，所以看起来如同直接在主内存中读写访问一般。



Java 线程、主内存和工作内存三者的交互关系如图 12-2 所示（与图 12-2 对比）：

![12-2](https://github.com/JiaoXR/ReadingNotes/blob/master/pics/JVM/working_memory.png)



###  内存交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下 8 种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外）。

8 种操作如下：

| 操作          | 作用范围 | 作用                                                         |
| ------------- | -------- | ------------------------------------------------------------ |
| lock (锁定)   | 主内存   | 把变量标识为一条线程独占的状态                               |
| unlock (解锁) | 主内存   | 释放锁定状态的变量（释放后才可以被其他线程锁定）             |
| read (读取)   | 主内存   | 把变量的值从主内存传输到线程工作内存（以便随后的 read 使用） |
| load (载入)   | 工作内存 | 把 read 得到的变量值放入工作内存的变量副本中                 |
| use (使用)    | 工作内存 | 把工作内存中变量的值传递给执行引擎，<br />虚拟机遇到需要使用到变量值的字节码指令时执行该操作 |
| assign (赋值) | 工作内存 | 把从执行引擎接收到的值赋给工作内存的变量，<br />虚拟机遇到给变量赋值的字节码执行时执行该操作 |
| store (存储)  | 工作内存 | 把工作内存中变量的值传送到主内存中（以便随后的 write 使用）  |
| write (写入)  | 主内存   | 把 store 从工作内存中得到的变量的值放入主内存变量中          |

若要把变量从主内存复制到工作内存，就要顺序的执行 read 和 load 操作；

若要把变量从工作内存同步回主内存，就要顺序的执行 store 和 write 操作。

> 注意：二者有先后顺序要求，但不保证连续。



JMM 规定了在执行上述 8 种基本操作时必须满足以下规则：

- 不允许 read 和 load、store 和 write 操作之一单独出现（即，要成对出现）
- 不允许线程丢弃它最近的 assign 操作（即，变量在工作内存中改变之后必须同步回主内存）
- 不允许线程无原因地（无任何 assign 操作）把数据从工作内存同步回主内存
- 新的变量只能在主内存“诞生”，不允许工作内存中直接使用未被初始化（load 和 assign）的变量（即 load 后才能 use，assign 后才能 store）
- 一个变量在同一时刻只允许一条线程对其进行 lock，但 lock 可被同一线程重复执行多次（需要相同次数的 unlock 才能解锁）
- 若对变量执行 lock 操作，将会清空工作内存中该变量的值，执行引擎使用该变量前，需重新 load 或 assign
- 若变量未被 lock 锁定，则不允许对其进行 unlock；也不允许 unlock 其他线程锁定的变量
- 对变量执行 unlock 前，必须先把该变量同步回主内存中（执行 store、write 操作）

###  对 volatile 型变量的特殊规则























