# 第 12 章  通过异常处理错误

> Java 的基本理念是“结构不佳的代码不能运行”。

###  异常参数

所有标准异常类都有两个构造器：一个是默认的构造器；另一个是接收字符串作为参数，以便能把相关信息放入异常对象的构造器。例如：

```java
throw new NullPointerException("t == null");
```

###  终止与恢复

异常处理理论上有两种基本模型：终止模型和恢复模型。

- 终止模型

该模型假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。

- 恢复模型

即异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。对于恢复模型，通常希望异常被处理之后能继续执行程序。

若想用 Java 实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。或者，把 try  块放在 while 循环中，不断地进入 try 块，直到得到满意的结果。

- 可以声明方法将异常抛出，实际上却不抛出

好处：为异常先占个位子，以后就可以抛出这种异常而不用修改已有的代码。在定义抽象基类和接口时这种能力很重要。。

###  重新抛出异常

- fillInStackTrace：调用 `fillInStackTrace()` 方法的那一行就成了异常的新发生地。
- 有可能在捕获异常之后抛出另一种异常。这么做的话，得到的结果类似于使用 `fillInStackTrace()` ，有关原来异常发生点的信息会丢失，剩下的是与新的抛出点有关的信息。
- 永远不必为异常对象的清理而担心。它们都是用 new 在堆上创建的对象，

##  Java 标准异常

Throwable 表示任何可以作为异常被抛出的类。Throwable 对象可分为两种类型：

- Error

表示编译时和系统错误（除特殊情况外，一般无需关心）；

- Exception

可以被抛出的基本类型。

###  分类

- 被检查的异常

在编译时被强制检查的异常称为”被检查的异常“。

- 不受检查异常
  - 不需要在异常说明中声明方法将抛出 RuntimeException 类型的异常（或者任何从 RuntimeException 继承的异常），它们被称为“不受检查异常”。
  - 尽管通常不用捕获 RuntimeException 异常，但还是可以在代码中抛出 RuntimeException 类型的异常。

> 注：只能在代码中忽略 RuntimeException（及其子类）类型的异常，其他类型异常的处理都是由编译器强制实施的。究其原因，RuntimeException 代表的是编程错误。

###  使用 finally 进行清理

对于一些代码，可能会希望无论 try 块中的异常是否抛出，它们都能得到执行。为了达到这个效果，可以在异常处理程序后面加上 finally 字句。

###  异常的限制

当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。