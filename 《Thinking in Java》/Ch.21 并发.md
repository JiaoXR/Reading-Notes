# 第 21 章  并发
- Moore 定律已经有些过时了，速度提高是以多核处理器的形式而不是更快地芯片的形式出现的。为了使程序运行得更快，你必须学习如何利用这些额外的处理器，这正是并发赋予你的能力。
- 如果你有一台多处理器的机器，那么就可以在这些处理器之间分布多个任务，从而可以极大地提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。
- 但是，并发通常是提高运行在单处理器上的程序的性能。
- 实现并发最直接的方式是在操作系统级别使用进程。进程是运行在它自己的地址空间内的自包容的程序。多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个进程（程序）。
- 操作系统会将进程之间互相隔离开，它们不会彼此干涉。

####  抢占式&协作式

- Java的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片。
- 在协作式系统中，每个任务都会自动地放弃控制，这要求程序员👨‍💻‍要有意识地在每个任务中插入某种类型的让步语句。
  - 上下文切换的开销通常比抢占式系统要低廉许多，并且理论上对可以同时执行的线程没有限制；
  - 某些协作式系统并未设计为可以在多个处理器之间分布任务，可能会非常受限。

####  使用Executor

- Java SE5 的 `java.util.concurrent` 包中的执行器（Executor）将为你管理 Thread 对象，从而简化了并发编程。Executor 在客户端和任务执行之间提供了一个间接层。
- 注意：在任何线程池中，现有线程在可能的情况下，都会被自动复用。
- 本书使用 CachedThreadPool，但也应该考虑在产生线程的代码中使用 FixedThreadPool。CachedThreadPool 在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的 Executor 首选。只有当这种方式会引发问题时，才需要切换到 FixedThreadPool。
- SingleThreadExecutor 就像是线程数量为 1 的 FixedThreadPool。

####  从任务中产生返回值

- Runnable 是执行工作的独立任务，无返回值；若希望在任务完成时有返回值，可以实现 Callable 接口。
- Callable 接口具有类型参数的泛型，它的类型参数表示的是从 call() 方法中返回的值，且必须使用 ExecutorService.submit() 方法调用它。

####  优先级

- 线程的优先级将该线程的重要性传递给了调度器。尽管 CPU 处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。但并不意味着优先权较低的线程将得不到执行（即优先权不会导致死锁）。优先级较低的线程仅仅是执行的频率较低。
- 绝大多数时间，所有线程都应该以默认的优先级运行。试图操纵线程优先级通常是一种错误。

####  后台线程

- 后台（deamon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，且这种线程不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。
- 必须在程序启动之前调用 `setDeamon()` 方法，才能把它设置为后台线程。

####  捕获异常

- Thread.UncaughtExceptionHandler

####  解决共享资源竞争

- 基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。这意味着在给定时刻只允许一个任务访问共享资源（通常加锁来实现）。
- 因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量（mutex）。

####  临界区

- 有时只希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出来的代码段称被为临界区（critical section），它也使用 synchronized 关键字建立。
- 注意：synchronized 关键字不属于方法特征签名的组成部分，所以可以在覆盖方法的时候加上去。

##  终结任务

P724


